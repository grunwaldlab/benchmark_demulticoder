---
title: "Pooled amplicon analysis-directcompare"
output: html_document
date: "2024-12-24"
---

```{r setup}
library(phyloseq); packageVersion("phyloseq")
library(ggplot2); packageVersion("ggplot2")
library(readr); packageVersion("readr")
library(tidyr); packageVersion("tidyr")
library(purrr); packageVersion("purrr")
library(furrr); packageVersion("furrr")
library(dplyr); packageVersion("dplyr")
library(stringr); packageVersion("stringr")
library(forcats); packageVersion("forcats")
library(metacoder); packageVersion("metacoder")
library(data.table); packageVersion("data.table")
library(decontam); packageVersion("decontam")
library(Biostrings); packageVersion("Biostrings")
library(magick); packageVersion("magick")
library(vegan); packageVersion("vegan")
library(pdftools);packageVersion("pdftools")
library(vegan); packageVersion("vegan")
library(grid)
library(gridExtra)
knitr::opts_knit$set(root.dir = "~/benchmark_demulticoder")
```

### Alpha diversity-Let's do a direct comparison of mean inverse Simpson diversity between workflows
```{r alpha diversity comp}
# Read in the demulticoder data
stats_diversity_demulticoder<-read.csv("demulticoder/results/alpha_diversity.csv")
stats_diversity_sf <- read.csv("standard_workflow/combined_results/alpha_diversity.csv")

stats_diversity_demulticoder <- stats_diversity_demulticoder[order(stats_diversity_demulticoder$sample_name), ]
stats_diversity_sf <- stats_diversity_sf[order(stats_diversity_sf$sample_name), ]

stats_diversity_sf <- stats_diversity_sf[match(stats_diversity_demulticoder$sample_name, stats_diversity_sf$sample_name), ]

if (!all(stats_diversity_demulticoder$sample_name == stats_diversity_sf$sample_name)) {
  stop("Sample names do not match between the two data frames.")
}

sample_name <- stats_diversity_sf$sample_name
raw_demulticoder <- stats_diversity_demulticoder$raw_count
raw_sf <- stats_diversity_sf$raw_count
raw_count_diff <- stats_diversity_demulticoder$raw_count - stats_diversity_sf$raw_count
richness_demulticoder <- stats_diversity_demulticoder$richness
richness_sf <- stats_diversity_sf$richness
richness_diff <- stats_diversity_demulticoder$richness - stats_diversity_sf$richness
shannon_demulticoder <- stats_diversity_demulticoder$shannon
shannon_sf <- stats_diversity_sf$shannon
shannon_diff <- stats_diversity_demulticoder$shannon - stats_diversity_sf$shannon
invsimpson_demulticoder <- stats_diversity_demulticoder$invsimpson
invsimpson_sf <- stats_diversity_sf$invsimpson
invsimpson_diff <- stats_diversity_demulticoder$invsimpson - stats_diversity_sf$invsimpson

difference_df <- data.frame(sample_name, raw_demulticoder, raw_sf, raw_count_diff, richness_demulticoder, richness_sf, richness_diff, shannon_demulticoder, shannon_sf, shannon_diff, invsimpson_demulticoder, invsimpson_sf, invsimpson_diff)

# save csv
write.csv(difference_df, "demulticoder_comp_sf/results/alpha_diversity_comparison.csv", row.names = FALSE)

boxplot(raw_count_diff, main = "Raw Count Differences")
boxplot(richness_diff, main = "Richness Differences")
boxplot(shannon_diff, main = "Shannon Differences")
boxplot(invsimpson_diff, main = "Inverse Simpson Differences")

# Let's do a paired t-test and wilcoxon test for each of the alpha diversity metrics
# Raw count
wilcox.test(stats_diversity_demulticoder$raw_count, stats_diversity_sf$raw_count,paired = TRUE)
t.test(stats_diversity_demulticoder$raw_count, stats_diversity_sf$raw_count,paired = TRUE)

# Richness
wilcox.test(stats_diversity_demulticoder$richness, stats_diversity_sf$richness,paired = TRUE)
t.test(stats_diversity_demulticoder$richness, stats_diversity_sf$richness,paired = TRUE)

# Shanonn index
wilcox.test(stats_diversity_demulticoder$shannon, stats_diversity_sf$shannon,paired = TRUE)
t.test(stats_diversity_demulticoder$shannon, stats_diversity_sf$shannon,paired = TRUE)

#Inverse simpson
wilcox.test(stats_diversity_demulticoder$invsimpson, stats_diversity_sf$invsimpson,paired = TRUE)
t.test(stats_diversity_demulticoder$invsimpson, stats_diversity_sf$invsimpson,paired = TRUE)
```

### Make similar table for nmds data
```{r beta diversity comp}
# Read in the demulticoder data
nmds_demulticoder<-read.csv("demulticoder/results/compiled_stats.csv")
nmds_sf <- read.csv("standard_workflow/combined_results/compiled_stats.csv")

nmds_demulticoder <- nmds_demulticoder[order(nmds_demulticoder$sample_name), ]
nmds_sf <-nmds_sf[order(nmds_sf$sample_name), ]

nmds_sf <- nmds_sf[match(nmds_demulticoder$sample_name, nmds_sf$sample_name), ]

if (!all(nmds_demulticoder$sample_name == nmds_sf$sample_name)) {
  stop("Sample names do not match between the two data frames.")
}

nmds1_diff <- nmds_demulticoder$NMDS1 - nmds_sf$NMDS1
nmds2_diff <- nmds_demulticoder$NMDS2 - nmds_sf$NMDS2

sample_name_nmds <- nmds_sf$sample_name
#Add to new table
nmds_df <- data.frame(sample_name_nmds, nmds_demulticoder$NMDS1, nmds_sf$NMDS1, nmds1_diff, nmds_demulticoder$NMDS2, nmds_sf$NMDS2,  nmds2_diff)

# save csv
write.csv(nmds_df, "demulticoder_comp_sf/results/beta_diversity_comparison.csv", row.names = FALSE)
```


### Make facetted figure with alpha diversity and nmds data loaded above
Start with making demulticoder boxplots-alpha diversity
```{r facetted figure-alpha div demulticoder}
plotted_factors <- c('Organism' = 'organism', 'Flooded' = 'flooded', 'Pathogen Concentration' = 'path_conc', 'Trial' = 'experiment')

alpha_plot_data <- plotted_factors %>%
  map2_dfr(names(plotted_factors), function(factor_col, factor_name) {
    out <- stats_diversity_demulticoder
    out$factor <- factor_name
    out$value <- as.character(out[[factor_col]])
    return(out)
  }) %>%
  mutate(path_conc = factor(path_conc, levels = sort(unique(path_conc)), labels = paste(sort(unique(path_conc)), 'CFU/g'), ordered = TRUE)) %>%
  filter(sample_type == 'Sample') %>%
  select(sample_name, factor, value, invsimpson) %>%
  tidyr::gather(key = "index", value = "diversity", -sample_name, -factor, -value) %>%
  mutate(value = forcats::fct_relevel(ordered(value), "Control", "Cin", "Plu", "Cry"))

alpha_plot_data <- alpha_plot_data %>%
  mutate(value = recode(value, "FALSE" = "Not Flooded", "TRUE" = "Flooded", "Control" = "Con"))

anova_and_hsd <- function(x) {
  anova_result <- aov(diversity ~ value, x)
  tukey_result <- agricolae::HSD.test(anova_result, "value", group = TRUE)
  group_data <- tukey_result$groups[order(rownames(tukey_result$groups)),]
  group_key <- setNames(group_data$groups, rownames(group_data))
  group_key[as.character(x$value)]
}
alpha_plot_data$group <- unlist(map(split(alpha_plot_data, alpha_plot_data$factor)[unique(alpha_plot_data$factor)], anova_and_hsd))

alpha_subplot_demulticoder <- ggplot(alpha_plot_data, aes(x = value, y = diversity)) +
  geom_boxplot(color = "black", fill = "white") +
  geom_text(aes(x = value, y = max(diversity) + 2, label = group), col = 'black', size = 5) +
  facet_grid(~ factor, scales = "free") +
  labs(x = NULL, y = 'Diversity (Inverse Simpson)') +
  guides(color = "none") +
  theme(panel.background = element_rect(fill = "white"),
        panel.grid.major.x = element_blank(),
        panel.grid.minor = element_blank(),
        panel.grid.major.y = element_line(color = "gray"),
        axis.text.x = element_text(angle = 45, hjust = 1, color = "black"),
        axis.text.y = element_text(color = "black"),
        axis.title.y = element_text(color = "black"),
        legend.position = "bottom",
        panel.border = element_rect(color = "black", fill = NA, size = 1),
        strip.background = element_rect(fill = "white", color = "white"),
        strip.text = element_text(color = "black"))

print(alpha_subplot_demulticoder)
```

Start with making standard workflow boxplots-alpha diversity
```{r facetted figure-alpha div standard wf}
plotted_factors <- c('Organism' = 'organism', 'Flooded' = 'flooded', 'Pathogen Concentration' = 'path_conc', 'Trial' = 'experiment')

alpha_plot_data <- plotted_factors %>%
  map2_dfr(names(plotted_factors), function(factor_col, factor_name) {
    out <- stats_diversity_sf
    out$factor <- factor_name
    out$value <- as.character(out[[factor_col]])
    return(out)
  }) %>%
  mutate(path_conc = factor(path_conc, levels = sort(unique(path_conc)), labels = paste(sort(unique(path_conc)), 'CFU/g'), ordered = TRUE)) %>%
  filter(sample_type == 'Sample') %>%
  select(sample_name, factor, value, invsimpson) %>%
  tidyr::gather(key = "index", value = "diversity", -sample_name, -factor, -value) %>%
  mutate(value = forcats::fct_relevel(ordered(value), "Control", "Cin", "Plu", "Cry"))

alpha_plot_data <- alpha_plot_data %>%
  mutate(value = recode(value, "FALSE" = "Not Flooded", "TRUE" = "Flooded", "Control" = "Con"))

anova_and_hsd <- function(x) {
  anova_result <- aov(diversity ~ value, x)
  tukey_result <- agricolae::HSD.test(anova_result, "value", group = TRUE)
  group_data <- tukey_result$groups[order(rownames(tukey_result$groups)),]
  group_key <- setNames(group_data$groups, rownames(group_data))
  group_key[as.character(x$value)]
}
alpha_plot_data$group <- unlist(map(split(alpha_plot_data, alpha_plot_data$factor)[unique(alpha_plot_data$factor)], anova_and_hsd))

alpha_subplot_sf <- ggplot(alpha_plot_data, aes(x = value, y = diversity)) +
  geom_boxplot(color = "black", fill = "white") +
  geom_text(aes(x = value, y = max(diversity) + 2, label = group), col = 'black', size = 5) +
  facet_grid(~ factor, scales = "free") +
  labs(x = NULL, y = 'Diversity (Inverse Simpson)') +
  guides(color = "none") +
  theme(panel.background = element_rect(fill = "white"),
        panel.grid.major.x = element_blank(),
        panel.grid.minor = element_blank(),
        panel.grid.major.y = element_line(color = "gray"),
        axis.text.x = element_text(angle = 45, hjust = 1, color = "black"),
        axis.text.y = element_text(color = "black"),
        axis.title.y = element_text(color = "black"),
        legend.position = "bottom",
        panel.border = element_rect(color = "black", fill = NA, size = 1),
        strip.background = element_rect(fill = "white", color = "white"),
        strip.text = element_text(color = "black"))

print(alpha_subplot_sf)
```

Start with making demulticoder nmds plots
```{r facetted figure-beta div-demulticoder}
nmds_factors <- c(Flooded = 'flooded', Organism = 'organism', 'Pathogen CFU/g' = 'path_conc', 'Trial' = 'experiment')

nmds_data <- nmds_demulticoder

nmds_data <- nmds_data %>%
  mutate(flooded = as.character(flooded),
         flooded = recode(flooded, "TRUE" = "Flooded", "FALSE" = "Not Flooded"),
         organism = recode(organism, "Control" = "Con"))

make_one_plot <- function(factor, name) {
  nmds_data %>%
    mutate(factor = as.character(nmds_data[[factor]]),
           NMDS1 = scales::rescale(NMDS1),
           NMDS2 = scales::rescale(NMDS2)) %>%
    mutate(factor = fct_relevel(ordered(factor), "Con", "Cin", "Plu", "Cry")) %>%
    ggplot(aes_string(x = "NMDS1", y = "NMDS2", color = "factor", label = "sample_name")) +
    geom_point() +
    coord_fixed() +
    viridis::scale_color_viridis(discrete = TRUE, end = .9) +
    labs(color = NULL, x = "NMDS1", y = "NMDS2") +
    theme(panel.background = element_rect(fill = "white"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.text = element_text(size = 8),
          axis.title = element_text(size = 10),
          axis.ticks = element_line(color = "black"),
          plot.margin = unit(rep(0.04, 4), "cm"),
          legend.position = "bottom",
          legend.text = element_text(size = 10),
          legend.key.height = unit(0.25, 'cm'),
          legend.key.width = unit(0.1, 'cm'),
          legend.spacing = unit(0.05, 'cm'),
          legend.margin = margin(t = -0.2, unit = 'cm'),
          panel.border = element_rect(color = "black", fill = NA, size = 1)) +
    guides(color = guide_legend(nrow = 2, byrow = TRUE))
}


nmds_subplots <- map2(nmds_factors, names(nmds_factors), make_one_plot)
nmds_plot_demulticoder <- ggpubr::ggarrange(plotlist = c(list(ggplot() + theme_void()), nmds_subplots),
                       nrow = 1, widths = c(0.15, 1, 1, 1, 1))

nmds_plot_demulticoder
```

Start with making standard workflow nmds plots
```{r facetted figure-beta div-demulticoder}
nmds_factors <- c(Flooded = 'flooded', Organism = 'organism', 'Pathogen CFU/g' = 'path_conc', 'Trial' = 'experiment')

nmds_data <- nmds_sf

nmds_data <- nmds_data %>%
  mutate(flooded = as.character(flooded),
         flooded = recode(flooded, "TRUE" = "Flooded", "FALSE" = "Not Flooded"),
         organism = recode(organism, "Control" = "Con"))

make_one_plot <- function(factor, name) {
  nmds_data %>%
    mutate(factor = as.character(nmds_data[[factor]]),
           NMDS1 = scales::rescale(NMDS1),
           NMDS2 = scales::rescale(NMDS2)) %>%
    mutate(factor = fct_relevel(ordered(factor), "Con", "Cin", "Plu", "Cry")) %>%
    ggplot(aes_string(x = "NMDS1", y = "NMDS2", color = "factor", label = "sample_name")) +
    geom_point() +
    coord_fixed() +
    viridis::scale_color_viridis(discrete = TRUE, end = .9) +
    labs(color = NULL, x = "NMDS1", y = "NMDS2") +
    theme(panel.background = element_rect(fill = "white"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.text = element_text(size = 8),
          axis.title = element_text(size = 10),
          axis.ticks = element_line(color = "black"),
          plot.margin = unit(rep(0.04, 4), "cm"),
          legend.position = "bottom",
          legend.text = element_text(size = 10),
          legend.key.height = unit(0.25, 'cm'),
          legend.key.width = unit(0.1, 'cm'),
          legend.spacing = unit(0.05, 'cm'),
          legend.margin = margin(t = -0.2, unit = 'cm'),
          panel.border = element_rect(color = "black", fill = NA, size = 1)) +
    guides(color = guide_legend(nrow = 2, byrow = TRUE))
}


nmds_subplots <- map2(nmds_factors, names(nmds_factors), make_one_plot)
nmds_plot_sf <- ggpubr::ggarrange(plotlist = c(list(ggplot() + theme_void()), nmds_subplots),
                       nrow = 1, widths = c(0.15, 1, 1, 1, 1))

nmds_plot_sf
```

#Now facet into A-D
```{r facet figure-beta div}
library(cowplot)

# Combine the plots
combined_div_plot <- plot_grid(alpha_subplot_demulticoder, alpha_subplot_sf, nmds_plot_demulticoder, nmds_plot_sf, 
                               ncol = 2, labels = c('A', 'B', 'C', 'D'), 
                               rel_heights = c(0.5, 0.5, 1, 1))

# Adjust the layout to reduce white space and adjust margins
combined_div_plot <- combined_div_plot + 
  theme(plot.margin = unit(c(1, 1, 1, 1), "cm"))

# Save the plot with the specified dimensions
ggsave(combined_div_plot, path = "demulticoder_comp_sf/figures", filename = "diversity_demulticoder_sf.pdf", 
       width = 14.5, height = 7, bg = "#FFFFFF")

ggsave(combined_div_plot, path = "demulticoder_comp_sf/figures", filename = "diversity_demulticoder_sf.svg", 
       width = 14.5, height = 7, bg = "#FFFFFF")
```

### Convert ASV matrices to taxmap objects-old db
```{r convert to taxmap obj-compare old and new db}
obj_olddb <- parse_tax_data(asv_matrix_rps10_oldb, class_cols = 'dada2_tax', class_sep = ';',
                      class_regex = '^(.+)--(.+)--(.+)$',
                      class_key = c(taxon = 'taxon_name', boot = 'info', rank = 'taxon_rank'))
names(obj_olddb$data) <- c('abund', 'score')
obj_olddb <- transmute_obs(obj_olddb, 'score', sequence = sequence[input_index], boot = boot, rank = rank)


# For diversity calculations, we'll use proportions of read depth
# We'll set any proportion to 0 that is less than the inverse of the read count of the non-control sample with the fewest reads.
# This should account for unequal sample read depth without the randomness of rarefaction.

metadata$raw_count <- colSums(obj_olddb$data$abund[, metadata$sample_name])
lowest_count <- min(metadata$raw_count[! is.na(metadata$organism)])
lowest_count
obj_olddb$data$prop <- calc_obs_props(obj_olddb, data = 'abund', cols = metadata$sample_name)
obj_olddb$data$prop <- zero_low_counts(obj_olddb, data = 'prop', min_count = 1 / lowest_count, cols = metadata$sample_name)
obj_olddb$data$prop

obj_olddb$data$prop[metadata$sample_name] <- map(metadata$sample_name, function(id) {
  out <- obj_olddb$data$prop[[id]]
  out[is.na(out) | is.nan(out)] <- 0
  out
})

obj_olddb$data$prop
```

### Community composition plot-new db-showcase differences in bootstrap support values
```{r, overall community plot new db}
min_bootstrap <- 60
obj_newdb$data$score$boot <- as.numeric(obj_newdb$data$score$boot)
max_boot <- obj_newdb$data$score %>%
  group_by(taxon_id) %>%
  summarise(max = max(boot))
max_boot <- setNames(max_boot$max, max_boot$taxon_id)
obj_newdb <- filter_taxa(obj_newdb, max_boot[taxon_ids] >= min_bootstrap | taxon_ranks %in% c("ASV", "Reference"), reassign_obs = c(abund = TRUE, score = FALSE))

obj_newdb$data$asv_prop <- calc_obs_props(obj_newdb, 'abund', cols = metadata$sample_name)
obj_newdb$data$tax_abund <- calc_taxon_abund(obj_newdb, 'abund', cols = metadata$sample_name)
obj_newdb$data$tax_prop <- calc_taxon_abund(obj_newdb, 'asv_prop', cols = metadata$sample_name)
obj_newdb$data$tax_data <- calc_n_samples(obj_newdb, 'tax_prop', cols = metadata$sample_name[metadata$sample_type == 'Sample'])
obj_newdb$data$tax_data$mean_prop <- rowMeans(obj_newdb$data$tax_prop[, metadata$sample_name])

obj_newdb %>%
  filter_taxa(taxon_ranks == "Species", supertaxa = TRUE, reassign_obs = c(tax_abund = FALSE)) 

# Calculate the relative standard deviation for each taxon as a measure of how consistently it was found.
rsd <- function(x, na.rm = FALSE) {sd(x, na.rm = na.rm) / mean(x, na.rm = na.rm)}
obj_newdb$data$tax_data$rel_stand_dev <- map_dbl(1:nrow(obj_newdb$data$tax_abund), function(i) {
  rsd(unlist(obj_newdb$data$tax_abund[i, metadata$sample_name]), na.rm = TRUE)
})

max_boot <- obj_newdb$data$score %>%
  group_by(taxon_id) %>%
  summarise(max = max(boot))

# Map the maximum bootstrap support to taxon IDs
max_boot <- setNames(max_boot$max, max_boot$taxon_id)

# Add maximum bootstrap support to tax_data
obj_newdb$data$tax_data$max_boot <- max_boot[match(obj_newdb$data$tax_data$taxon_id, names(max_boot))]

set.seed(10)

obj_newdb %>%
  filter_taxa(! is_stem) %>%
  filter_taxa(n_samples >= 1, supertaxa = TRUE, reassign_obs = FALSE) %>%
  filter_taxa(! grepl(x = taxon_names, "_sp$"), reassign_obs = FALSE) %>%
  filter_taxa(! grepl(x = taxon_names, "incertae_sedis", ignore.case = TRUE), reassign_obs = FALSE) %>%
  remove_redundant_names() %>%
  heat_tree(node_size = mean_prop,
            edge_size = n_samples,
            node_color = ifelse(is.na(max_boot), 0, max_boot),
            node_color_range = c("#D2042D","#fc8d62","#a6d854","#66c2a5","lightblue","#b8c0cf"),
            node_label = taxon_names,
            node_size_range = c(0.01, 0.03), 
            node_label_size_range = c(0.014, 0.02),
            edge_label_size_range = c(0.012, 0.015), 
            node_size_interval = c(0, 1),
            edge_size_range = c(0.002, 0.01), 
            layout = "da", initial_layout = "re",
            node_color_axis_label = "Bootstrap support",
            node_size_axis_label = "Mean proportion of reads",
            edge_size_axis_label = "Number of samples",
            node_color_digits = 2,
            node_size_digits = 2,
            edge_color_digits = 2,
            edge_size_digits = 2,
            #aspect_ratio = 1.618,
            output_file = file.path('demulticoder/figures', '/heattree_mostabund_taxa_rps10_newdb_boot60_greater1.pdf'))
```

### Community composition plot-old db-showcase differences in bootstrap support values
```{r, overall community plot}
### Community composition plot-new db-showcase differences in bootstrap support values
min_bootstrap <- 60
obj_olddb$data$score$boot <- as.numeric(obj_olddb$data$score$boot)
max_boot <- obj_olddb$data$score %>%
  group_by(taxon_id) %>%
  summarise(max = max(boot))
max_boot <- setNames(max_boot$max, max_boot$taxon_id)
obj_olddb <- filter_taxa(obj_olddb, max_boot[taxon_ids] >= min_bootstrap | taxon_ranks %in% c("ASV", "Reference"), reassign_obs = c(abund = TRUE, score = FALSE))

obj_olddb$data$asv_prop <- calc_obs_props(obj_olddb, 'abund', cols = metadata$sample_name)
obj_olddb$data$tax_abund <- calc_taxon_abund(obj_olddb, 'abund', cols = metadata$sample_name)
obj_olddb$data$tax_prop <- calc_taxon_abund(obj_olddb, 'asv_prop', cols = metadata$sample_name)
obj_olddb$data$tax_data <- calc_n_samples(obj_olddb, 'tax_prop', cols = metadata$sample_name[metadata$sample_type == 'Sample'])
obj_olddb$data$tax_data$mean_prop <- rowMeans(obj_olddb$data$tax_prop[, metadata$sample_name])

obj_olddb %>%
  filter_taxa(taxon_ranks == "Species", supertaxa = TRUE, reassign_obs = c(tax_abund = FALSE)) 

# Calculate the relative standard deviation for each taxon as a measure of how consistently it was found.
rsd <- function(x, na.rm = FALSE) {sd(x, na.rm = na.rm) / mean(x, na.rm = na.rm)}
obj_olddb$data$tax_data$rel_stand_dev <- map_dbl(1:nrow(obj_olddb$data$tax_abund), function(i) {
  rsd(unlist(obj_olddb$data$tax_abund[i, metadata$sample_name]), na.rm = TRUE)
})

max_boot <- obj_olddb$data$score %>%
  group_by(taxon_id) %>%
  summarise(max = max(boot))

# Map the maximum bootstrap support to taxon IDs
max_boot <- setNames(max_boot$max, max_boot$taxon_id)

# Add maximum bootstrap support to tax_data
obj_olddb$data$tax_data$max_boot <- max_boot[match(obj_olddb$data$tax_data$taxon_id, names(max_boot))]


set.seed(10)

obj_olddb %>%
  filter_taxa(! is_stem) %>%
  filter_taxa(n_samples >= 1, supertaxa = TRUE, reassign_obs = FALSE) %>%
  filter_taxa(! grepl(x = taxon_names, "_sp$"), reassign_obs = FALSE) %>%
  filter_taxa(! grepl(x = taxon_names, "incertae_sedis", ignore.case = TRUE), reassign_obs = FALSE) %>%
  remove_redundant_names() %>%
  heat_tree(node_size = mean_prop,
            edge_size = n_samples,
            node_color = ifelse(is.na(max_boot), 0, max_boot),
            node_color_range = c("#D2042D","#fc8d62","#a6d854","#66c2a5","lightblue","#b8c0cf"),
            node_label = taxon_names,
            node_size_range = c(0.01, 0.03), 
            node_label_size_range = c(0.014, 0.02),
            edge_label_size_range = c(0.012, 0.015), 
            node_size_interval = c(0, 1),
            edge_size_range = c(0.002, 0.01), 
            layout = "da", initial_layout = "re",
            node_color_axis_label = "Bootstrap support",
            node_size_axis_label = "Mean proportion of reads",
            edge_size_axis_label = "Number of samples",
            node_color_digits = 2,
            node_size_digits = 2,
            edge_color_digits = 2,
            edge_size_digits = 2,
            #aspect_ratio = 1.618,
            output_file = file.path('demulticoder/figures', '/heattree_mostabund_taxa_rps10_olddb_boot60_greater1.pdf'))
```

Let's facet the two plots so we have a side-by-side comparison of the two databases. 
```{r, facet community plot,fig.height=30, fig.width=30, message=FALSE, echo=FALSE}
old_db <- image_read_pdf("demulticoder/figures/heattree_mostabund_taxa_rps10_olddb_boot60_greater1.pdf")
new_db <- image_read_pdf("demulticoder/figures/heattree_mostabund_taxa_rps10_newdb_boot60_greater1.pdf")

max_width <- max(image_info(old_db)$width, image_info(new_db)$width)
max_height <- max(image_info(old_db)$height, image_info(new_db)$height)

old_db_resized <- image_resize(old_db, paste0(max_width, "x", max_height, "!"))
new_db_resized <- image_resize(new_db, paste0(max_width, "x", max_height, "!"))

old_grob <- rasterGrob(as.raster(old_db))
new_grob <- rasterGrob(as.raster(new_db))

pdf("demulticoder/figures/combined_heat_trees_db_compare_boot60_greater1.pdf", width=8, height=6)
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 2, 
                                           heights = unit(c(0.1, 1), "null"),
                                           widths = unit(c(1, 1), "null"))))

place_grob <- function(grob, row, col, label) {
  pushViewport(viewport(layout.pos.row = row, layout.pos.col = col))
  grid.text(label, y = unit(1, "npc") + unit(0.5, "lines"), 
            gp = gpar(fontsize = 12, fontface = "bold"))
  pushViewport(viewport(height = unit(0.9, "npc")))
  grid.draw(grob)
  upViewport(2)
}

place_grob(old_grob, 2, 1, "A. Original oomyceteDB database")
place_grob(new_grob, 2, 2, "B. Updated oomyceteDB database")

dev.off()
```

### Summary stats comparing db
```{r, summary stats, message=FALSE, echo=FALSE}
# Extract the taxonomic assignments and bootstrap support values
new_taxa <- asv_matrix_rps10 %>% select(sequence, dada2_tax)
old_taxa <- asv_matrix_rps10_oldb %>% select(sequence, dada2_tax)

# Merge the old and new taxonomic assignments on sequence
merged_taxa <- merge(old_taxa, new_taxa, by = "sequence", suffixes = c("_old", "_new"))

# Function to extract bootstrap values from the taxonomic string
extract_bootstrap <- function(tax_string) {
  values <- unlist(strsplit(tax_string, ";"))
  numeric_values <- sapply(values, function(x) {
    parts <- unlist(strsplit(x, "--"))
    if (length(parts) >= 2) {
      return(as.numeric(parts[2]))
    } else {
      return(NA)
    }
  })
  return(paste(numeric_values, collapse = ";"))
}

# Apply the function to extract bootstrap values for old and new taxonomies
merged_taxa$dada2_tax_old_boot <- sapply(merged_taxa$dada2_tax_old, extract_bootstrap)
merged_taxa$dada2_tax_new_boot <- sapply(merged_taxa$dada2_tax_new, extract_bootstrap)

# Create a new dataframe with rows where dada2_tax_old and dada2_tax_new don't match
mismatched_taxa <- merged_taxa %>% filter(dada2_tax_old != dada2_tax_new)

# Print the mismatched taxa dataframe
print(mismatched_taxa)

# Write the merged dataframe to a CSV file
write.csv(merged_taxa, "demulticoder/results/taxdifferences_oldnewdb.csv")
```

```{r session info}
sessioninfo::session_info()
```