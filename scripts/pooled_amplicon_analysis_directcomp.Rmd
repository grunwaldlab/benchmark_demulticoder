---
title: "Pooled amplicon analysis-directcompare"
output: html_document
date: "2024-12-24"
---

```{r setup}
library(phyloseq); packageVersion("phyloseq")
library(ggplot2); packageVersion("ggplot2")
library(readr); packageVersion("readr")
library(tidyr); packageVersion("tidyr")
library(purrr); packageVersion("purrr")
library(furrr); packageVersion("furrr")
library(dplyr); packageVersion("dplyr")
library(stringr); packageVersion("stringr")
library(forcats); packageVersion("forcats")
library(metacoder); packageVersion("metacoder")
library(data.table); packageVersion("data.table")
library(decontam); packageVersion("decontam")
library(Biostrings); packageVersion("Biostrings")
library(magick); packageVersion("magick")
library(vegan); packageVersion("vegan")
library(pdftools);packageVersion("pdftools")
library(vegan); packageVersion("vegan")
library(grid)
library(gridExtra)
knitr::opts_knit$set(root.dir = "~/benchmark_demulticoder")
```

### Alpha diversity-Let's do a direct comparison of mean inverse Simpson diversity between workflows

```{r alpha diversity comp}
# Read in the demulticoder data
stats_diversity_demulticoder<-read.csv("demulticoder/results/alpha_diversity.csv")
stats_diversity_sf <- read.csv("standard_workflow/combined_results/alpha_diversity.csv")

stats_diversity_demulticoder <- stats_diversity_demulticoder[order(stats_diversity_demulticoder$sample_name), ]
stats_diversity_sf <- stats_diversity_sf[order(stats_diversity_sf$sample_name), ]

stats_diversity_sf <- stats_diversity_sf[match(stats_diversity_demulticoder$sample_name, stats_diversity_sf$sample_name), ]

if (!all(stats_diversity_demulticoder$sample_name == stats_diversity_sf$sample_name)) {
  stop("Sample names do not match between the two data frames.")
}

raw_count_diff <- stats_diversity_demulticoder$raw_count - stats_diversity_sf$raw_count
richness_diff <- stats_diversity_demulticoder$richness - stats_diversity_sf$richness
shannon_diff <- stats_diversity_demulticoder$shannon - stats_diversity_sf$shannon
invsimpson_diff <- stats_diversity_demulticoder$invsimpson - stats_diversity_sf$invsimpson

#Add to new table
difference_df <- data.frame(raw_count_diff, richness_diff, shannon_diff, invsimpson_diff)
```

### Make summary boxplot showing inverse simpson values

### Convert ASV matrices to taxmap objects-old db
```{r convert to taxmap obj-compare old and new db}
obj_olddb <- parse_tax_data(asv_matrix_rps10_oldb, class_cols = 'dada2_tax', class_sep = ';',
                      class_regex = '^(.+)--(.+)--(.+)$',
                      class_key = c(taxon = 'taxon_name', boot = 'info', rank = 'taxon_rank'))
names(obj_olddb$data) <- c('abund', 'score')
obj_olddb <- transmute_obs(obj_olddb, 'score', sequence = sequence[input_index], boot = boot, rank = rank)


# For diversity calculations, we'll use proportions of read depth
# We'll set any proportion to 0 that is less than the inverse of the read count of the non-control sample with the fewest reads.
# This should account for unequal sample read depth without the randomness of rarefaction.

metadata$raw_count <- colSums(obj_olddb$data$abund[, metadata$sample_name])
lowest_count <- min(metadata$raw_count[! is.na(metadata$organism)])
lowest_count
obj_olddb$data$prop <- calc_obs_props(obj_olddb, data = 'abund', cols = metadata$sample_name)
obj_olddb$data$prop <- zero_low_counts(obj_olddb, data = 'prop', min_count = 1 / lowest_count, cols = metadata$sample_name)
obj_olddb$data$prop

obj_olddb$data$prop[metadata$sample_name] <- map(metadata$sample_name, function(id) {
  out <- obj_olddb$data$prop[[id]]
  out[is.na(out) | is.nan(out)] <- 0
  out
})

obj_olddb$data$prop
```

### Community composition plot-new db-showcase differences in bootstrap support values
```{r, overall community plot new db}
min_bootstrap <- 60
obj_newdb$data$score$boot <- as.numeric(obj_newdb$data$score$boot)
max_boot <- obj_newdb$data$score %>%
  group_by(taxon_id) %>%
  summarise(max = max(boot))
max_boot <- setNames(max_boot$max, max_boot$taxon_id)
obj_newdb <- filter_taxa(obj_newdb, max_boot[taxon_ids] >= min_bootstrap | taxon_ranks %in% c("ASV", "Reference"), reassign_obs = c(abund = TRUE, score = FALSE))

obj_newdb$data$asv_prop <- calc_obs_props(obj_newdb, 'abund', cols = metadata$sample_name)
obj_newdb$data$tax_abund <- calc_taxon_abund(obj_newdb, 'abund', cols = metadata$sample_name)
obj_newdb$data$tax_prop <- calc_taxon_abund(obj_newdb, 'asv_prop', cols = metadata$sample_name)
obj_newdb$data$tax_data <- calc_n_samples(obj_newdb, 'tax_prop', cols = metadata$sample_name[metadata$sample_type == 'Sample'])
obj_newdb$data$tax_data$mean_prop <- rowMeans(obj_newdb$data$tax_prop[, metadata$sample_name])

obj_newdb %>%
  filter_taxa(taxon_ranks == "Species", supertaxa = TRUE, reassign_obs = c(tax_abund = FALSE)) 

# Calculate the relative standard deviation for each taxon as a measure of how consistently it was found.
rsd <- function(x, na.rm = FALSE) {sd(x, na.rm = na.rm) / mean(x, na.rm = na.rm)}
obj_newdb$data$tax_data$rel_stand_dev <- map_dbl(1:nrow(obj_newdb$data$tax_abund), function(i) {
  rsd(unlist(obj_newdb$data$tax_abund[i, metadata$sample_name]), na.rm = TRUE)
})

max_boot <- obj_newdb$data$score %>%
  group_by(taxon_id) %>%
  summarise(max = max(boot))

# Map the maximum bootstrap support to taxon IDs
max_boot <- setNames(max_boot$max, max_boot$taxon_id)

# Add maximum bootstrap support to tax_data
obj_newdb$data$tax_data$max_boot <- max_boot[match(obj_newdb$data$tax_data$taxon_id, names(max_boot))]

set.seed(10)

obj_newdb %>%
  filter_taxa(! is_stem) %>%
  filter_taxa(n_samples >= 1, supertaxa = TRUE, reassign_obs = FALSE) %>%
  filter_taxa(! grepl(x = taxon_names, "_sp$"), reassign_obs = FALSE) %>%
  filter_taxa(! grepl(x = taxon_names, "incertae_sedis", ignore.case = TRUE), reassign_obs = FALSE) %>%
  remove_redundant_names() %>%
  heat_tree(node_size = mean_prop,
            edge_size = n_samples,
            node_color = ifelse(is.na(max_boot), 0, max_boot),
            node_color_range = c("#D2042D","#fc8d62","#a6d854","#66c2a5","lightblue","#b8c0cf"),
            node_label = taxon_names,
            node_size_range = c(0.01, 0.03), 
            node_label_size_range = c(0.014, 0.02),
            edge_label_size_range = c(0.012, 0.015), 
            node_size_interval = c(0, 1),
            edge_size_range = c(0.002, 0.01), 
            layout = "da", initial_layout = "re",
            node_color_axis_label = "Bootstrap support",
            node_size_axis_label = "Mean proportion of reads",
            edge_size_axis_label = "Number of samples",
            node_color_digits = 2,
            node_size_digits = 2,
            edge_color_digits = 2,
            edge_size_digits = 2,
            #aspect_ratio = 1.618,
            output_file = file.path('demulticoder/figures', '/heattree_mostabund_taxa_rps10_newdb_boot60_greater1.pdf'))
```

### Community composition plot-old db-showcase differences in bootstrap support values
```{r, overall community plot}
### Community composition plot-new db-showcase differences in bootstrap support values
min_bootstrap <- 60
obj_olddb$data$score$boot <- as.numeric(obj_olddb$data$score$boot)
max_boot <- obj_olddb$data$score %>%
  group_by(taxon_id) %>%
  summarise(max = max(boot))
max_boot <- setNames(max_boot$max, max_boot$taxon_id)
obj_olddb <- filter_taxa(obj_olddb, max_boot[taxon_ids] >= min_bootstrap | taxon_ranks %in% c("ASV", "Reference"), reassign_obs = c(abund = TRUE, score = FALSE))

obj_olddb$data$asv_prop <- calc_obs_props(obj_olddb, 'abund', cols = metadata$sample_name)
obj_olddb$data$tax_abund <- calc_taxon_abund(obj_olddb, 'abund', cols = metadata$sample_name)
obj_olddb$data$tax_prop <- calc_taxon_abund(obj_olddb, 'asv_prop', cols = metadata$sample_name)
obj_olddb$data$tax_data <- calc_n_samples(obj_olddb, 'tax_prop', cols = metadata$sample_name[metadata$sample_type == 'Sample'])
obj_olddb$data$tax_data$mean_prop <- rowMeans(obj_olddb$data$tax_prop[, metadata$sample_name])

obj_olddb %>%
  filter_taxa(taxon_ranks == "Species", supertaxa = TRUE, reassign_obs = c(tax_abund = FALSE)) 

# Calculate the relative standard deviation for each taxon as a measure of how consistently it was found.
rsd <- function(x, na.rm = FALSE) {sd(x, na.rm = na.rm) / mean(x, na.rm = na.rm)}
obj_olddb$data$tax_data$rel_stand_dev <- map_dbl(1:nrow(obj_olddb$data$tax_abund), function(i) {
  rsd(unlist(obj_olddb$data$tax_abund[i, metadata$sample_name]), na.rm = TRUE)
})

max_boot <- obj_olddb$data$score %>%
  group_by(taxon_id) %>%
  summarise(max = max(boot))

# Map the maximum bootstrap support to taxon IDs
max_boot <- setNames(max_boot$max, max_boot$taxon_id)

# Add maximum bootstrap support to tax_data
obj_olddb$data$tax_data$max_boot <- max_boot[match(obj_olddb$data$tax_data$taxon_id, names(max_boot))]


set.seed(10)

obj_olddb %>%
  filter_taxa(! is_stem) %>%
  filter_taxa(n_samples >= 1, supertaxa = TRUE, reassign_obs = FALSE) %>%
  filter_taxa(! grepl(x = taxon_names, "_sp$"), reassign_obs = FALSE) %>%
  filter_taxa(! grepl(x = taxon_names, "incertae_sedis", ignore.case = TRUE), reassign_obs = FALSE) %>%
  remove_redundant_names() %>%
  heat_tree(node_size = mean_prop,
            edge_size = n_samples,
            node_color = ifelse(is.na(max_boot), 0, max_boot),
            node_color_range = c("#D2042D","#fc8d62","#a6d854","#66c2a5","lightblue","#b8c0cf"),
            node_label = taxon_names,
            node_size_range = c(0.01, 0.03), 
            node_label_size_range = c(0.014, 0.02),
            edge_label_size_range = c(0.012, 0.015), 
            node_size_interval = c(0, 1),
            edge_size_range = c(0.002, 0.01), 
            layout = "da", initial_layout = "re",
            node_color_axis_label = "Bootstrap support",
            node_size_axis_label = "Mean proportion of reads",
            edge_size_axis_label = "Number of samples",
            node_color_digits = 2,
            node_size_digits = 2,
            edge_color_digits = 2,
            edge_size_digits = 2,
            #aspect_ratio = 1.618,
            output_file = file.path('demulticoder/figures', '/heattree_mostabund_taxa_rps10_olddb_boot60_greater1.pdf'))
```

Let's facet the two plots so we have a side-by-side comparison of the two databases. 
```{r, facet community plot,fig.height=30, fig.width=30, message=FALSE, echo=FALSE}
old_db <- image_read_pdf("demulticoder/figures/heattree_mostabund_taxa_rps10_olddb_boot60_greater1.pdf")
new_db <- image_read_pdf("demulticoder/figures/heattree_mostabund_taxa_rps10_newdb_boot60_greater1.pdf")

max_width <- max(image_info(old_db)$width, image_info(new_db)$width)
max_height <- max(image_info(old_db)$height, image_info(new_db)$height)

old_db_resized <- image_resize(old_db, paste0(max_width, "x", max_height, "!"))
new_db_resized <- image_resize(new_db, paste0(max_width, "x", max_height, "!"))

old_grob <- rasterGrob(as.raster(old_db))
new_grob <- rasterGrob(as.raster(new_db))

pdf("demulticoder/figures/combined_heat_trees_db_compare_boot60_greater1.pdf", width=8, height=6)
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 2, 
                                           heights = unit(c(0.1, 1), "null"),
                                           widths = unit(c(1, 1), "null"))))

place_grob <- function(grob, row, col, label) {
  pushViewport(viewport(layout.pos.row = row, layout.pos.col = col))
  grid.text(label, y = unit(1, "npc") + unit(0.5, "lines"), 
            gp = gpar(fontsize = 12, fontface = "bold"))
  pushViewport(viewport(height = unit(0.9, "npc")))
  grid.draw(grob)
  upViewport(2)
}

place_grob(old_grob, 2, 1, "A. Original oomyceteDB database")
place_grob(new_grob, 2, 2, "B. Updated oomyceteDB database")

dev.off()
```

### Summary stats comparing db
```{r, summary stats, message=FALSE, echo=FALSE}
# Extract the taxonomic assignments and bootstrap support values
new_taxa <- asv_matrix_rps10 %>% select(sequence, dada2_tax)
old_taxa <- asv_matrix_rps10_oldb %>% select(sequence, dada2_tax)

# Merge the old and new taxonomic assignments on sequence
merged_taxa <- merge(old_taxa, new_taxa, by = "sequence", suffixes = c("_old", "_new"))

# Function to extract bootstrap values from the taxonomic string
extract_bootstrap <- function(tax_string) {
  values <- unlist(strsplit(tax_string, ";"))
  numeric_values <- sapply(values, function(x) {
    parts <- unlist(strsplit(x, "--"))
    if (length(parts) >= 2) {
      return(as.numeric(parts[2]))
    } else {
      return(NA)
    }
  })
  return(paste(numeric_values, collapse = ";"))
}

# Apply the function to extract bootstrap values for old and new taxonomies
merged_taxa$dada2_tax_old_boot <- sapply(merged_taxa$dada2_tax_old, extract_bootstrap)
merged_taxa$dada2_tax_new_boot <- sapply(merged_taxa$dada2_tax_new, extract_bootstrap)

# Create a new dataframe with rows where dada2_tax_old and dada2_tax_new don't match
mismatched_taxa <- merged_taxa %>% filter(dada2_tax_old != dada2_tax_new)

# Print the mismatched taxa dataframe
print(mismatched_taxa)

# Write the merged dataframe to a CSV file
write.csv(merged_taxa, "demulticoder/results/taxdifferences_oldnewdb.csv")
```

```{r session info}
sessioninfo::session_info()
```